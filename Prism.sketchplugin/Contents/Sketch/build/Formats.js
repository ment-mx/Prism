// Generated by CoffeeScript 1.12.7
var AndroidJavaFormatter, AndroidXMLFormatter, CLRFormatter, ColorSetFormatter, HexFormatter, RGBACSSFormatter, SASSFormatter, SketchMeasureFormatter, UIColorObjCFormatter, UIColorSwiftFormatter,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

AndroidJavaFormatter = (function(superClass) {
  extend(AndroidJavaFormatter, superClass);

  function AndroidJavaFormatter() {
    return AndroidJavaFormatter.__super__.constructor.apply(this, arguments);
  }

  AndroidJavaFormatter.prototype.id = function() {
    return "ANDROID";
  };

  AndroidJavaFormatter.prototype.name = function() {
    return "Android ARGB (Java code)";
  };

  AndroidJavaFormatter.prototype.format = function() {
    return "colors.java";
  };

  AndroidJavaFormatter.prototype.formatText = function(color, commented) {
    var formattedColor;
    formattedColor = "Color.argb(" + (Math.round(color.alpha * 255)) + "," + (Math.round(color.red * 255)) + "," + (Math.round(color.green * 255)) + "," + (Math.round(color.blue * 255)) + ");";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  return AndroidJavaFormatter;

})(FormatterBase);

AndroidXMLFormatter = (function(superClass) {
  extend(AndroidXMLFormatter, superClass);

  function AndroidXMLFormatter() {
    return AndroidXMLFormatter.__super__.constructor.apply(this, arguments);
  }

  AndroidXMLFormatter.prototype.id = function() {
    return "ANDROID_XML";
  };

  AndroidXMLFormatter.prototype.name = function() {
    return "Android ARGB (XML)";
  };

  AndroidXMLFormatter.prototype.format = function() {
    return "colors.xml";
  };

  AndroidXMLFormatter.prototype.formatText = function(color, commented) {
    var formattedColor, xmlVariable;
    formattedColor = "" + helperHex(color.alpha * 255) + color.hex;
    xmlVariable = '<color name="' + color.name.toLowerCase().trim().split(" ").join("_") + '">#' + formattedColor + "</color>";
    return xmlVariable;
  };

  return AndroidXMLFormatter;

})(FormatterBase);

CLRFormatter = (function(superClass) {
  extend(CLRFormatter, superClass);

  function CLRFormatter() {
    return CLRFormatter.__super__.constructor.apply(this, arguments);
  }

  CLRFormatter.prototype.id = function() {
    return "CLR";
  };

  CLRFormatter.prototype.name = function() {
    return "CLR (Color Lists)";
  };

  CLRFormatter.prototype.format = function() {
    return "colors.clr";
  };

  CLRFormatter.prototype.supportClipboard = function() {
    return false;
  };

  CLRFormatter.prototype.exportAsFile = function(colorDictionaries, url) {
    var alpha, blue, color, colorDictionary, colorList, green, i, len, red;
    colorList = NSColorList.alloc().initWithName("colors");
    for (i = 0, len = colorDictionaries.length; i < len; i++) {
      colorDictionary = colorDictionaries[i];
      red = Math.round(colorDictionary.red * 100) / 100;
      green = Math.round(colorDictionary.green * 100) / 100;
      blue = Math.round(colorDictionary.blue * 100) / 100;
      alpha = Math.round(colorDictionary.alpha * 100) / 100;
      color = NSColor.colorWithSRGBRed_green_blue_alpha(red, green, blue, alpha);
      colorList.setColor_forKey(color, colorDictionary.name);
    }
    return colorList.writeToFile(url.path());
  };

  return CLRFormatter;

})(FormatterBase);

ColorSetFormatter = (function(superClass) {
  extend(ColorSetFormatter, superClass);

  function ColorSetFormatter() {
    return ColorSetFormatter.__super__.constructor.apply(this, arguments);
  }

  ColorSetFormatter.prototype.id = function() {
    return "COLORSET";
  };

  ColorSetFormatter.prototype.name = function() {
    return "Color set (Xcode named color)";
  };

  ColorSetFormatter.prototype.type = function() {
    return this.constructor.EXPORT_TYPE_FILES;
  };

  ColorSetFormatter.prototype.supportClipboard = function() {
    return false;
  };

  ColorSetFormatter.prototype.exportAsFile = function(colorDictionaries, url) {
    var colorDictionary, colorsetURL, fileName, fileString, i, len, manager, name, obj, path, results;
    manager = NSFileManager.defaultManager();
    results = [];
    for (i = 0, len = colorDictionaries.length; i < len; i++) {
      colorDictionary = colorDictionaries[i];
      obj = this.contentsJSON(colorDictionary);
      name = colorDictionary.name.toLowerCase().trim().split(" ").join("_");
      fileName = name + ".colorset";
      colorsetURL = url.URLByAppendingPathComponent(fileName);
      manager.createDirectoryAtPath_withIntermediateDirectories_attributes_error(colorsetURL.path(), true, null, null);
      path = colorsetURL.path();
      fileString = NSString.stringWithString(JSON.stringify(obj, null, 4));
      results.push(fileString.writeToFile_atomically_encoding_error(path + "/Contents.json", true, NSUTF8StringEncoding, null));
    }
    return results;
  };

  ColorSetFormatter.prototype.contentsJSON = function(colorDictionary) {
    var c, obj;
    c = this.colorObject(colorDictionary);
    return obj = {
      info: {
        version: 1,
        author: "com.ment.sketch.prism"
      },
      colors: [c]
    };
  };

  ColorSetFormatter.prototype.colorObject = function(colorDictionary) {
    var color, obj;
    color = {
      "color-space": "display-p3",
      components: this.colorComponents(colorDictionary)
    };
    return obj = {
      idiom: "universal",
      color: color
    };
  };

  ColorSetFormatter.prototype.colorComponents = function(colorDictionary) {
    var obj;
    return obj = {
      red: parseFloat(colorDictionary.red).toFixed(3),
      green: parseFloat(colorDictionary.green).toFixed(3),
      blue: parseFloat(colorDictionary.blue).toFixed(3),
      alpha: parseFloat(colorDictionary.alpha).toFixed(3)
    };
  };

  return ColorSetFormatter;

})(FormatterBase);

HexFormatter = (function(superClass) {
  extend(HexFormatter, superClass);

  function HexFormatter() {
    return HexFormatter.__super__.constructor.apply(this, arguments);
  }

  HexFormatter.prototype.id = function() {
    return "HEX";
  };

  HexFormatter.prototype.name = function() {
    return "HEX CSS";
  };

  HexFormatter.prototype.format = function() {
    return "colors.css";
  };

  HexFormatter.prototype.formatText = function(color, commented) {
    var formattedColor;
    formattedColor = '#' + color.hex;
    if (commented) {
      return formattedColor + "; /* " + color.name + " */";
    } else {
      return formattedColor;
    }
  };

  return HexFormatter;

})(FormatterBase);

RGBACSSFormatter = (function(superClass) {
  extend(RGBACSSFormatter, superClass);

  function RGBACSSFormatter() {
    return RGBACSSFormatter.__super__.constructor.apply(this, arguments);
  }

  RGBACSSFormatter.prototype.id = function() {
    return "RGBA_CSS";
  };

  RGBACSSFormatter.prototype.name = function() {
    return "RGBA CSS";
  };

  RGBACSSFormatter.prototype.format = function() {
    return "colors.css";
  };

  RGBACSSFormatter.prototype.formatText = function(color, commented) {
    var alpha, formattedColor;
    alpha = color.alpha < 1 ? color.alpha.toFixed(2) : color.alpha;
    formattedColor = "rgba(" + (Math.round(color.red * 255)) + "," + (Math.round(color.green * 255)) + "," + (Math.round(color.blue * 255)) + "," + alpha + ");";
    if (commented) {
      return formattedColor + " /* " + color.name + " */";
    } else {
      return formattedColor;
    }
  };

  return RGBACSSFormatter;

})(FormatterBase);

SASSFormatter = (function(superClass) {
  extend(SASSFormatter, superClass);

  function SASSFormatter() {
    return SASSFormatter.__super__.constructor.apply(this, arguments);
  }

  SASSFormatter.prototype.id = function() {
    return "SASS";
  };

  SASSFormatter.prototype.name = function() {
    return "SASS variables";
  };

  SASSFormatter.prototype.format = function() {
    return "_colors.scss";
  };

  SASSFormatter.prototype.formatText = function(color, commented) {
    var formattedColor, sassVariableName;
    formattedColor = '#' + color.hex;
    sassVariableName = '$' + color.name.toLowerCase().trim().split(" ").join("-").replace("'", "");
    return sassVariableName + ": " + formattedColor + ";";
  };

  return SASSFormatter;

})(FormatterBase);

SketchMeasureFormatter = (function(superClass) {
  extend(SketchMeasureFormatter, superClass);

  function SketchMeasureFormatter() {
    return SketchMeasureFormatter.__super__.constructor.apply(this, arguments);
  }

  SketchMeasureFormatter.prototype.id = function() {
    return "SKETCHMESURE_JSON";
  };

  SketchMeasureFormatter.prototype.name = function() {
    return "Sketch Measure (JSON)";
  };

  SketchMeasureFormatter.prototype.format = function() {
    return "colors.json";
  };

  SketchMeasureFormatter.prototype.supportClipboard = function() {
    return true;
  };

  SketchMeasureFormatter.prototype.exportAsString = function(colorDictionaries) {
    var colorDictionary, i, len, obj, root;
    root = [];
    for (i = 0, len = colorDictionaries.length; i < len; i++) {
      colorDictionary = colorDictionaries[i];
      log(colorDictionary);
      obj = {
        "name": "" + (colorDictionary.name.trim()),
        "color": this.colorToDictionaryToJSON(colorDictionary)
      };
      root.push(obj);
    }
    return JSON.stringify(root, void 0, 4);
  };

  SketchMeasureFormatter.prototype.colorToDictionaryToJSON = function(colorDictionary) {
    var json;
    return json = {
      r: Math.round(colorDictionary.red * 255),
      g: Math.round(colorDictionary.green * 255),
      b: Math.round(colorDictionary.blue * 255),
      a: Math.round(colorDictionary.alpha * 100) / 100,
      "color-hex": ("\#" + colorDictionary.hex + " ") + ((Math.round(colorDictionary.alpha * 100)) + "%"),
      "argb-hex": "\#" + (helperHex(colorDictionary.alpha * 255) + colorDictionary.hex),
      "css-rgba": "rgba(" + (Math.round(colorDictionary.red * 255)) + "," + (Math.round(colorDictionary.green * 255)) + "," + (Math.round(colorDictionary.blue * 255)) + "," + (Math.round(colorDictionary.alpha * 100) / 100) + ")",
      "ui-color": "(r:" + (parseFloat(colorDictionary.red).toFixed(3)) + " g:" + (parseFloat(colorDictionary.green).toFixed(3)) + " b:" + (parseFloat(colorDictionary.blue).toFixed(3)) + " a:" + (parseFloat(colorDictionary.alpha).toFixed(3)) + ")"
    };
  };

  return SketchMeasureFormatter;

})(FormatterBase);

UIColorObjCFormatter = (function(superClass) {
  extend(UIColorObjCFormatter, superClass);

  function UIColorObjCFormatter() {
    return UIColorObjCFormatter.__super__.constructor.apply(this, arguments);
  }

  UIColorObjCFormatter.prototype.id = function() {
    return "UICOLOR_OBJC";
  };

  UIColorObjCFormatter.prototype.name = function() {
    return "UIColor (Objective-C)";
  };

  UIColorObjCFormatter.prototype.format = function() {
    return "colors.m";
  };

  UIColorObjCFormatter.prototype.formatText = function(color, commented) {
    var alpha, blue, formattedColor, green, red;
    red = Math.round(color.red * 100) / 100;
    green = Math.round(color.green * 100) / 100;
    blue = Math.round(color.blue * 100) / 100;
    alpha = Math.round(color.alpha * 100) / 100;
    formattedColor = "[UIColor colorWithRed:" + red + " green:" + green + " blue:" + blue + " alpha:" + alpha + "];";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  return UIColorObjCFormatter;

})(FormatterBase);

UIColorSwiftFormatter = (function(superClass) {
  extend(UIColorSwiftFormatter, superClass);

  function UIColorSwiftFormatter() {
    return UIColorSwiftFormatter.__super__.constructor.apply(this, arguments);
  }

  UIColorSwiftFormatter.prototype.id = function() {
    return "UICOLOR_SWIFT";
  };

  UIColorSwiftFormatter.prototype.name = function() {
    return "UIColor (Swift)";
  };

  UIColorSwiftFormatter.prototype.format = function() {
    return "colors.m";
  };

  UIColorSwiftFormatter.prototype.formatText = function(color, commented) {
    var alpha, blue, formattedColor, green, red;
    red = Math.round(color.red * 100) / 100;
    green = Math.round(color.green * 100) / 100;
    blue = Math.round(color.blue * 100) / 100;
    alpha = Math.round(color.alpha * 100) / 100;
    formattedColor = "UIColor(red:" + red + ", green:" + green + ", blue:" + blue + ", alpha:" + alpha + ")";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  return UIColorSwiftFormatter;

})(FormatterBase);
